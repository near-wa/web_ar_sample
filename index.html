<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ar sample</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #startButton{ font-size: 50px; }
    </style>
</head>
<body>
    <button type="button" id="startButton">ar start</button>

    <canvas id="xrCanvas"></canvas>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.113.2/build/three.module.js'
        let xrHitTestSource = null;
        let xrViewerSpace = null;
        const width = window.innerWidth;
        const height = window.innerHeight;

        const startButton = document.getElementById('startButton');

        ( async () => {
            const isArSupported = navigator.xr && await navigator.xr.isSessionSupported('immersive-ar');
            startButton.disabled = !isArSupported;
            startButton.addEventListener('click', onEnterAr);

            async function onEnterAr() {
                startButton.style.display = 'none';

                const xrSession = await navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']});
                xrSession.addEventListener('select', onSelect);

                const renderer = new THREE.WebGLRenderer( { canvas: xrCanvas });
                renderer.autoClear = false;
                renderer.setSize(width, height);

                const gl = renderer.getContext();

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                scene.add(new THREE.GridHelper(100, 100));

                const box = new THREE.Mesh(
                new THREE.BoxBufferGeometry( .2, .2, .2 ),
                new THREE.MeshNormalMaterial(),
                );
                scene.add( box );

                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry( 0.1, 0.5, 32, 32 ),
                    new THREE.MeshNormalMaterial(),
                );
                scene.add( cone );

                const xrWebGLLayer = new XRWebGLLayer( xrSession, gl);
                xrSession.updateRenderState({ baseLayer: xrWebGLLayer });

                const referenceSpace = await xrSession.requestReferenceSpace('local');

                const hitTestInputReferenceSpace = await xrSession.requestReferenceSpace( 'viewer' );
                const hitTestSource = await xrSession.requestHitTestSource( { space: hitTestInputReferenceSpace } );

                // xrSession.requestAnimationFrame( onDrawFrame );
                xrSession.requestAnimationFrame( putItem );

                // function onDrawFrame(timestamp, xrFrame) {
                //     xrSession.requestAnimationFrame(onDrawFrame);
                //     const pose = xrFrame.getViewerPose(referenceSpace);
                //     gl.bindFramebuffer(gl.FRAMEBUFFER, xrWebGLLayer.framebuffer);

                //     if (!pose) return;

                //     pose.views.forEach( (view) => {
                //         const viewport = xrWebGLLayer.getViewport( view );
                //         renderer.setSize( viewport.width, viewport.height );

                //         camera.matrix.fromArray( view.transform.matrix );
                //         camera.projectionMatrix.fromArray( view.projectionMatrix );
                //         camera.updateMatrixWorld( true );

                //         renderer.clearDepth();
                //         renderer.render( scene, camera );
                //     });
                // }

                function putItem(timestamp, xrFrame) {
                    xrSession.requestAnimationFrame( putItem );
                    // 姿勢を取り出す。行列（matrix）の要素が格納された配列で受け取ることができる。
                    const pose = xrFrame.getViewerPose( referenceSpace );

                    // xrFrame からは、現在のセッション、とベースレイヤーを取り出すこともできる。
                    // xrFrame.session === xrSession;
                    // xrSession.renderState.baseLayer === xrWebGLLayer;

                    // ヒットテストを実行する。
                    if ( hitTestSource ) {

                        const hitTestResults = xrFrame.getHitTestResults( hitTestSource );

                        // なにかにヒットしていたら、最初にヒットした平面の座標を取得する。
                        // 座標は pose として取得でき、その中に位置や角度が格納されている。
                        if ( hitTestResults.length > 0 ) {

                        const pose = hitTestResults[ 0 ].getPose( referenceSpace );

                        cone.position.set(
                            pose.transform.position.x,
                            pose.transform.position.y,
                            pose.transform.position.z
                        );
                        cone.quaternion.set(
                            pose.transform.orientation.x,
                            pose.transform.orientation.y,
                            pose.transform.orientation.z,
                            pose.transform.orientation.w,
                        );

                        }
                    }

                    // 現実の風景をWebGLのフレームバッファーに転写する
                    gl.bindFramebuffer( gl.FRAMEBUFFER, xrWebGLLayer.framebuffer );

                    if ( ! pose ) return;

                    // if the xrSession is for both right and left eyes, length of views would be 2.
                    // if not, length is 1,
                    pose.views.forEach( ( view ) => {

                    const viewport = xrWebGLLayer.getViewport( view );
                    renderer.setSize( viewport.width, viewport.height );

                    camera.matrix.fromArray( view.transform.matrix );
                    camera.projectionMatrix.fromArray( view.projectionMatrix );
                    camera.updateMatrixWorld( true );

                    renderer.clearDepth();
                    renderer.render( scene, camera );

                    } );
                }

                function onSelect() {
                    console.log(cone)
                    addConeObject(cone)
                }

                function addConeObject(cone) {
                    const newCone = new THREE.Mesh(
                        new THREE.ConeGeometry( 0.1, 0.5, 32, 32 ),
                        new THREE.MeshNormalMaterial(),
                    );
                    scene.add( newCone );
                    newCone.position.set(
                        cone.transform.position.x,
                        cone.transform.position.y,
                        cone.transform.position.z
                    );
                    newCone.quaternion.set(
                        cone.transform.orientation.x,
                        cone.transform.orientation.y,
                        cone.transform.orientation.z,
                        cone.transform.orientation.w,
                    );
                }
            }
        })();
    </script>
</body>
</html>