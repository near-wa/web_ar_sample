<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
        #startButton{
            font-size: 50px;
        }
    </style>
</head>
<body>
    <button type="button" id="startButton">click to start</button>

    <canvas id="xrCanvas"></canvas>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.113.2/build/three.module.js'

        const width = window.innerWidth;
        const height = window.innerHeight;
        const startButton = document.getElementById('startButton');
        let xrHitTestSource = null;
        let xrViewerSpace = null;

        ( async () => {
            const isArSupported = navigator.xr && await navigator.xr.isSessionSupported('immersive-ar');
            startButton.disabled = !isArSupported;
            startButton.addEventListener('click', onEnterAr);

            async function onEnterAr() {
                startButton.style.display = 'none';

                const xrSession = await navigator.xr.requestSession('immersive-ar');
                xrSession.addEventListener('select', onSelect);

                const renderer = new THREE.WebGLRenderer( { canvas: xrCanvas });
                renderer.autoClear = false;
                renderer.setSize(width, height);

                const gl = renderer.getContext();

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                scene.add(new THREE.GridHelper(100, 100));

                // const box = new THREE.Mesh(
                //     new THREE.BoxBufferGeometry( .2, .2, .2 ),
                //     new THREE.MeshNormalMaterial()
                // );

                // scene.add(box);

                const texture = new THREE.TextureLoader().load('./hikaru.jpg',
                    (texture) => { // 読み込み完了時
                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                        });
                        const cube = new THREE.Mesh(new THREE.BoxBufferGeometry( .2, .2, .2 ), material);
                        scene.add(cube);
                    }
                );

                const xrWebGLLayer = new XRWebGLLayer( xrSession, gl);
                xrSession.updateRenderState({ baseLayer: xrWebGLLayer });
                const referenceSpace = await xrSession.requestReferenceSpace('local');

                xrSession.requestReferenceSpace('viewer').then((refSpace) => {
                    xrViewerSpace = refSpace;
                    xrSession.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
                        xrHitTestSource = hitTestSource;
                    });
                });

                xrSession.requestAnimationFrame( onDrawFrame );
                xrSession.requestAnimationFrame( putItem );

                function onDrawFrame(timestamp, xrFrame) {
                    xrSession.requestAnimationFrame(onDrawFrame);
                    const pose = xrFrame.getViewerPose(referenceSpace);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, xrWebGLLayer.framebuffer);

                    if (!pose) return;

                    pose.views.forEach( (view) => {
                        const viewport = xrWebGLLayer.getViewport( view );
                        renderer.setSize( viewport.width, viewport.height );

                        camera.matrix.fromArray( view.transform.matrix );
                        camera.projectionMatrix.fromArray( view.projectionMatrix );
                        camera.updateMatrixWorld( true );

                        renderer.clearDepth();
                        renderer.render( scene, camera );
                    });
                }

                function putItem(timestamp, xrFrame) {
                    let session = xrFrame.session;
                    let pose = xrFrame.getViewerPose(xrRefSpace);

                    // If we have a hit test source, get its results for the frame
                    // and use the pose to display a reticle in the scene.
                    if (xrHitTestSource && pose) {
                        let hitTestResults = xrFrame.getHitTestResults(xrHitTestSource);
                        if (hitTestResults.length > 0) {
                            let pose = hitTestResults[0].getPose(xrRefSpace);
                            // reticle.visible = true;
                            // reticle.matrix = pose.transform.matrix;
                        }
                    }

                    console.log(pose.transform.matrix)
                }

                function onSelect() {
                    console.log('select')
                }
            }
        })();
    </script>
</body>
</html>