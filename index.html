<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ar sample</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #startButton{ font-size: 50px; }
    </style>
</head>
<body>
    <button type="button" id="startButton">ar start</button>

    <canvas id="xrCanvas"></canvas>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.113.2/build/three.module.js'
        let xrHitTestSource = null;
        let xrViewerSpace = null;
        const width = window.innerWidth;
        const height = window.innerHeight;

        const startButton = document.getElementById('startButton');

        ( async () => {
            const isArSupported = navigator.xr && await navigator.xr.isSessionSupported('immersive-ar');
            startButton.disabled = !isArSupported;
            startButton.addEventListener('click', onEnterAr);

            async function onEnterAr() {
                startButton.style.display = 'none';

                const xrSession = await navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']});
                xrSession.addEventListener('select', onSelect);

                const renderer = new THREE.WebGLRenderer( { canvas: xrCanvas });
                renderer.autoClear = false;
                renderer.setSize(width, height);

                const gl = renderer.getContext();

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry( 0.1, 0.5, 32, 32 ),
                    new THREE.MeshNormalMaterial(),
                );
                scene.add( cone );

                const createTexture = (filePath) => {
                    return new THREE.TextureLoader().load(filePath);
                }
                const wideImageTexture = createTexture(
                    './hikaru.jpg'
                );

                const createSprite = (texture, position, quaternion) => {
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(0.5, 0.5, 0.5);
                    // sprite.position.set(position.x, position.y, position.z);
                    scene.add(sprite);
                    sprite.position.set(
                        position.x,
                        position.y,
                        position.z
                    );
                    sprite.quaternion.set(
                        quaternion.x,
                        quaternion.y,
                        quaternion.z,
                        quaternion.w
                    );
                };

                const xrWebGLLayer = new XRWebGLLayer( xrSession, gl);
                xrSession.updateRenderState({ baseLayer: xrWebGLLayer });

                const referenceSpace = await xrSession.requestReferenceSpace('local');

                const hitTestInputReferenceSpace = await xrSession.requestReferenceSpace( 'viewer' );
                const hitTestSource = await xrSession.requestHitTestSource( { space: hitTestInputReferenceSpace } );

                xrSession.requestAnimationFrame( putItem );

                function putItem(timestamp, xrFrame) {
                    xrSession.requestAnimationFrame( putItem );
                    // 姿勢を取り出す。行列（matrix）の要素が格納された配列で受け取ることができる。
                    const pose = xrFrame.getViewerPose( referenceSpace );

                    // xrFrame からは、現在のセッション、とベースレイヤーを取り出すこともできる。
                    // xrFrame.session === xrSession;
                    // xrSession.renderState.baseLayer === xrWebGLLayer;

                    // ヒットテストを実行する。
                    if ( hitTestSource ) {

                        const hitTestResults = xrFrame.getHitTestResults( hitTestSource );

                        // なにかにヒットしていたら、最初にヒットした平面の座標を取得する。
                        // 座標は pose として取得でき、その中に位置や角度が格納されている。
                        if ( hitTestResults.length > 0 ) {

                        const pose = hitTestResults[ 0 ].getPose( referenceSpace );

                        cone.position.set(
                            pose.transform.position.x,
                            pose.transform.position.y,
                            pose.transform.position.z
                        );
                        cone.quaternion.set(
                            pose.transform.orientation.x,
                            pose.transform.orientation.y,
                            pose.transform.orientation.z,
                            pose.transform.orientation.w,
                        );

                        }
                    }

                    // 現実の風景をWebGLのフレームバッファーに転写する
                    gl.bindFramebuffer( gl.FRAMEBUFFER, xrWebGLLayer.framebuffer );

                    if ( ! pose ) return;

                    // if the xrSession is for both right and left eyes, length of views would be 2.
                    // if not, length is 1,
                    pose.views.forEach( ( view ) => {

                    const viewport = xrWebGLLayer.getViewport( view );
                    renderer.setSize( viewport.width, viewport.height );

                    camera.matrix.fromArray( view.transform.matrix );
                    camera.projectionMatrix.fromArray( view.projectionMatrix );
                    camera.updateMatrixWorld( true );

                    renderer.clearDepth();
                    renderer.render( scene, camera );

                    } );
                }

                function onSelect() {
                    console.log(cone)
                    addConeObject(cone)
                }

                function addConeObject(cone) {
                    createSprite(wideImageTexture, cone.position, cone.quaternion)
                }


            }
        })();
    </script>
</body>
</html>